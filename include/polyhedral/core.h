#ifndef _H_polyfp_CORE_
#define _H_polyfp_CORE_

#include <isl/set.h>
#include <isl/map.h>
#include <isl/union_map.h>
#include <isl/union_set.h>
#include <isl/ast_build.h>
#include <isl/schedule.h>
#include <isl/schedule_node.h>
#include <isl/space.h>
#include <isl/constraint.h>

#include <map>
#include <string.h>
#include <stdint.h>
#include <unordered_map>
#include <unordered_set>
#include <sstream>

// #include <Halide.h>
#include "debug.h"
#include "expr.h"
#include "type.h"
#include "codegen.h"

namespace polyfp{

class view;
class input;
class scheduler;
class compute;
class buffer;
class constant;
class generator;
class computation_tester;

//*******************************************************

/**
  * Initialize the polyfp compiler and set polyfp options to default
  * values.
  * \p fct_name is the name of the function to be generated by the polyfp compiler.
  * This is the name that the user will call to execute the generated code.
  */
void init(std::string name);

/**
  * \overload
  */
void init();

// int add(int i, int j) {
//     return i + j;
// }
/**
  * \brief Generate code.
  *
  * \details
  *
  * This function generates the declared function and computations in an object file.
  * \p obj_filename is the relative path of the object file to be generated.
  * If \p gen_cuda_stmt is set to true, CUDA code is generated instead of code
  * targeting CPU (i.e., instead of generating Halide IR then LLVM IR).
  */
// void codegen(const std::vector<polyfp::buffer *> &arguments, const std::string obj_filename, const bool gen_cuda_stmt = false);
void codegen();

compute *get_computation_annotated_in_a_node(isl_ast_node *node);


int loop_level_into_dynamic_dimension(int level);
int loop_level_into_static_dimension(int level);
int dynamic_dimension_into_loop_level(int dim);

isl_map *add_eq_to_schedule_map(int dim0, int in_dim_coefficient, int out_dim_coefficient,
                                int const_conefficient, isl_map *sched);


// polyfp::expr pmax(polyfp::expr left, polyfp::expr right){
//     return expr(polyfp::o_max, left, right);
// }


}


// #include <pybind11/pybind11.h>
// #include <pybind11/stl.h>
// namespace py = pybind11;
// int add(int i, int j);
// PYBIND11_MODULE(core, m) {
//     m.doc() = "pybind11 example plugin"; // optional module docstring
//     //  m.def("add", &add, "A function which adds two numbers");
//     m.def("add", &add);
//     // auto mlog = m.def_submodule("log");
//     // mlog.def("init", &polyfp::init);
//     m.def("init", py::overload_cast<std::string>(&polyfp::init), "A ");


// }


#endif
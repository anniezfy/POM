module {
  func @gemm(%arg0: f32, %arg1: f32, %arg2: memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>, %arg3: memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>, %arg4: memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>) attributes {resource = #hls.r<lut=0, dsp=5, bram=0>, timing = #hls.t<0 -> 24119302, 24119302, 24119302>, top_func} {
    affine.for %arg5 = 0 to 1024 {
      affine.for %arg6 = 0 to 1024 {
        %0 = affine.load %arg4[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        %1 = arith.mulf %0, %arg1 {timing = #hls.t<2 -> 6, 4, 1>} : f32
        affine.store %1, %arg4[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<6 -> 7, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
      } {loop_info = #hls.l<flattenTripCount=1024, iterLatency=7, minII=7>, timing = #hls.t<0 -> 7170, 7170, 7170>}
    } {loop_info = #hls.l<flattenTripCount=1024, iterLatency=7170, minII=7170>, timing = #hls.t<0 -> 7342082, 7342082, 7342082>}
    affine.for %arg5 = 0 to 1024 {
      affine.for %arg6 = 0 to 128 {
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 64, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 64, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 64, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 64, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 64, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 64, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 64, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 64, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 64, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 64, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 64, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 64, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 64, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 64, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 64, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 64, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 64, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 64, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 64, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 64, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 64, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 64, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 64, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 64, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 128, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 128, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 128, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 128, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 128, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 128, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 128, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 128, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 128, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 128, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 128, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 128, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 128, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 128, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 128, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 128, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 128, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 128, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 128, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 128, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 128, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 128, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 128, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 128, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 192, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 192, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 192, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 192, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 192, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 192, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 192, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 192, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 192, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 192, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 192, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 192, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 192, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 192, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 192, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 192, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 192, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 192, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 192, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 192, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 192, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 192, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 192, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 192, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 256, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 256, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 256, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 256, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 256, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 256, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 256, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 256, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 256, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 256, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 256, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 256, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 256, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 256, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 256, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 256, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 256, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 256, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 256, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 256, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 256, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 256, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 256, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 256, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 320, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 320, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 320, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 320, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 320, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 320, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 320, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 320, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 320, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 320, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 320, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 320, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 320, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 320, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 320, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 320, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 320, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 320, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 320, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 320, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 320, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 320, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 320, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 320, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 384, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 384, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 384, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 384, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 384, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 384, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 384, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 384, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 384, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 384, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 384, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 384, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 384, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 384, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 384, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 384, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 384, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 384, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 384, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 384, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 384, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 384, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 384, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 384, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 448, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 448, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 448, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 448, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 448, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 448, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 448, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 448, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 448, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 448, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 448, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 448, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 448, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 448, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 448, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 448, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 448, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 448, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 448, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 448, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 448, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 448, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 448, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 448, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 512, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 512, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 512, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 512, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 512, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 512, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 512, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 512, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 512, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 512, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 512, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 512, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 512, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 512, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 512, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 512, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 512, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 512, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 512, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 512, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 512, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 512, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 512, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 512, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 576, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 576, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 576, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 576, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 576, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 576, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 576, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 576, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 576, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 576, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 576, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 576, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 576, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 576, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 576, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 576, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 576, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 576, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 576, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 576, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 576, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 576, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 576, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 576, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 640, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 640, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 640, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 640, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 640, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 640, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 640, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 640, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 640, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 640, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 640, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 640, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 640, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 640, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 640, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 640, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 640, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 640, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 640, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 640, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 640, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 640, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 640, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 640, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 704, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 704, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 704, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 704, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 704, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 704, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 704, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 704, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 704, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 704, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 704, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 704, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 704, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 704, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 704, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 704, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 704, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 704, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 704, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 704, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 704, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 704, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 704, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 704, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 768, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 768, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 768, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 768, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 768, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 768, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 768, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 768, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 768, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 768, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 768, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 768, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 768, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 768, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 768, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 768, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 768, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 768, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 768, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 768, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 768, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 768, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 768, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 768, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 832, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 832, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 832, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 832, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 832, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 832, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 832, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 832, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 832, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 832, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 832, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 832, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 832, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 832, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 832, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 832, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 832, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 832, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 832, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 832, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 832, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 832, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 832, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 832, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 896, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 896, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 896, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 896, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 896, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 896, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 896, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 896, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 896, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 896, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 896, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 896, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 896, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 896, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 896, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 896, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 896, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 896, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 896, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 896, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 896, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 896, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 896, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 896, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 960, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 960, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 960, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 960, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 960, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 960, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 960, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 960, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 960, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 960, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 960, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 960, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 960, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 960, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 960, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 960, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 960, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 960, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 960, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 960, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 960, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 960, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 960, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 960, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1024, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1024, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1024, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1024, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1024, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1024, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1024, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1024, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1024, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1024, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1024, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1024, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1024, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1024, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1024, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1024, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1024, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1024, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1024, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1024, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1024, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1024, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1024, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1024, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1088, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1088, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1088, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1088, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1088, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1088, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1088, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1088, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1088, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1088, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1088, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1088, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1088, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1088, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1088, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1088, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1088, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1088, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1088, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1088, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1088, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1088, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1088, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1088, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1152, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1152, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1152, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1152, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1152, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1152, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1152, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1152, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1152, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1152, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1152, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1152, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1152, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1152, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1152, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1152, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1152, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1152, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1152, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1152, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1152, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1152, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1152, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1152, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1216, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1216, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1216, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1216, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1216, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1216, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1216, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1216, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1216, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1216, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1216, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1216, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1216, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1216, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1216, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1216, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1216, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1216, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1216, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1216, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1216, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1216, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1216, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1216, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1280, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1280, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1280, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1280, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1280, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1280, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1280, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1280, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1280, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1280, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1280, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1280, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1280, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1280, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1280, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1280, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1280, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1280, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1280, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1280, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1280, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1280, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1280, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1280, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1344, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1344, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1344, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1344, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1344, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1344, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1344, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1344, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1344, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1344, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1344, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1344, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1344, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1344, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1344, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1344, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1344, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1344, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1344, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1344, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1344, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1344, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1344, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1344, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1408, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1408, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1408, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1408, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1408, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1408, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1408, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1408, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1408, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1408, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1408, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1408, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1408, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1408, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1408, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1408, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1408, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1408, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1408, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1408, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1408, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1408, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1408, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1408, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1472, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1472, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1472, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1472, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1472, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1472, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1472, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1472, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1472, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1472, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1472, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1472, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1472, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1472, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1472, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1472, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1472, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1472, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1472, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1472, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1472, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1472, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1472, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1472, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1536, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1536, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1536, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1536, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1536, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1536, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1536, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1536, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1536, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1536, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1536, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1536, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1536, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1536, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1536, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1536, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1536, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1536, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1536, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1536, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1536, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1536, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1536, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1536, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1600, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1600, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1600, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1600, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1600, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1600, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1600, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1600, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1600, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1600, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1600, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1600, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1600, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1600, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1600, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1600, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1600, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1600, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1600, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1600, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1600, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1600, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1600, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1600, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1664, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1664, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1664, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1664, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1664, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1664, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1664, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1664, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1664, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1664, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1664, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1664, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1664, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1664, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1664, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1664, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1664, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1664, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1664, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1664, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1664, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1664, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1664, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1664, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1728, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1728, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1728, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1728, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1728, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1728, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1728, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1728, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1728, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1728, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1728, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1728, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1728, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1728, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1728, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1728, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1728, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1728, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1728, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1728, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1728, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1728, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1728, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1728, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1792, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1792, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1792, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1792, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1792, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1792, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1792, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1792, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1792, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1792, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1792, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1792, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1792, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1792, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1792, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1792, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1792, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1792, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1792, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1792, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1792, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1792, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1792, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1792, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1856, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1856, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1856, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1856, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1856, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1856, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1856, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1856, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1856, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1856, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1856, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1856, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1856, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1856, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1856, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1856, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1856, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1856, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1856, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1856, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1856, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1856, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1856, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1856, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1920, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1920, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1920, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1920, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1920, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1920, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1920, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1920, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1920, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1920, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1920, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1920, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1920, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1920, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1920, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1920, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1920, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1920, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1920, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1920, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1920, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1920, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1920, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1920, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1984, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1984, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1984, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1984, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1984, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1984, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1984, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1984, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1984, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1984, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1984, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1984, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1984, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1984, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1984, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1984, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1984, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1984, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1984, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1984, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1984, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 1984, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 1984, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 1984, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2048, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2048, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2048, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2048, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2048, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2048, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2048, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2048, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2048, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2048, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2048, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2048, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2048, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2048, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2048, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2048, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2048, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2048, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2048, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2048, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2048, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2048, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2048, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2048, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2112, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2112, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2112, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2112, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2112, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2112, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2112, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2112, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2112, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2112, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2112, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2112, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2112, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2112, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2112, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2112, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2112, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2112, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2112, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2112, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2112, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2112, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2112, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2112, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2176, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2176, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2176, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2176, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2176, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2176, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2176, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2176, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2176, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2176, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2176, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2176, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2176, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2176, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2176, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2176, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2176, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2176, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2176, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2176, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2176, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2176, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2176, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2176, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2240, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2240, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2240, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2240, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2240, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2240, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2240, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2240, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2240, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2240, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2240, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2240, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2240, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2240, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2240, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2240, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2240, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2240, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2240, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2240, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2240, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2240, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2240, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2240, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2304, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2304, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2304, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2304, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2304, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2304, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2304, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2304, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2304, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2304, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2304, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2304, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2304, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2304, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2304, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2304, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2304, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2304, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2304, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2304, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2304, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2304, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2304, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2304, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2368, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2368, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2368, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2368, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2368, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2368, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2368, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2368, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2368, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2368, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2368, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2368, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2368, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2368, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2368, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2368, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2368, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2368, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2368, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2368, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2368, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2368, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2368, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2368, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2432, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2432, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2432, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2432, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2432, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2432, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2432, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2432, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2432, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2432, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2432, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2432, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2432, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2432, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2432, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2432, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2432, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2432, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2432, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2432, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2432, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2432, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2432, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2432, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2496, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2496, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2496, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2496, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2496, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2496, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2496, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2496, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2496, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2496, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2496, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2496, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2496, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2496, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2496, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2496, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2496, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2496, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2496, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2496, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2496, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2496, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2496, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2496, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2560, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2560, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2560, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2560, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2560, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2560, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2560, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2560, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2560, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2560, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2560, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2560, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2560, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2560, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2560, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2560, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2560, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2560, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2560, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2560, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2560, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2560, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2560, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2560, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2624, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2624, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2624, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2624, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2624, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2624, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2624, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2624, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2624, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2624, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2624, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2624, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2624, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2624, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2624, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2624, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2624, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2624, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2624, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2624, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2624, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2624, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2624, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2624, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2688, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2688, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2688, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2688, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2688, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2688, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2688, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2688, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2688, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2688, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2688, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2688, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2688, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2688, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2688, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2688, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2688, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2688, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2688, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2688, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2688, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2688, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2688, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2688, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2752, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2752, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2752, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2752, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2752, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2752, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2752, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2752, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2752, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2752, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2752, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2752, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2752, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2752, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2752, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2752, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2752, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2752, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2752, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2752, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2752, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2752, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2752, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2752, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2816, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2816, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2816, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2816, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2816, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2816, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2816, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2816, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2816, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2816, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2816, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2816, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2816, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2816, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2816, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2816, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2816, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2816, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2816, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2816, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2816, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2816, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2816, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2816, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2880, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2880, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2880, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2880, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2880, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2880, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2880, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2880, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2880, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2880, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2880, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2880, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2880, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2880, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2880, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2880, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2880, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2880, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2880, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2880, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2880, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2880, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2880, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2880, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2944, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2944, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2944, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2944, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2944, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2944, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2944, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2944, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2944, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2944, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2944, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2944, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2944, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2944, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2944, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2944, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2944, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2944, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2944, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2944, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2944, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 2944, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 2944, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 2944, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3008, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3008, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3008, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3008, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3008, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3008, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3008, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3008, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3008, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3008, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3008, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3008, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3008, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3008, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3008, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3008, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3008, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3008, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3008, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3008, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3008, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3008, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3008, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3008, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3072, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3072, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3072, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3072, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3072, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3072, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3072, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3072, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3072, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3072, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3072, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3072, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3072, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3072, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3072, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3072, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3072, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3072, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3072, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3072, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3072, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3072, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3072, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3072, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3136, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3136, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3136, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3136, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3136, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3136, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3136, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3136, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3136, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3136, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3136, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3136, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3136, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3136, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3136, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3136, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3136, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3136, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3136, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3136, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3136, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3136, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3136, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3136, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3200, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3200, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3200, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3200, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3200, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3200, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3200, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3200, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3200, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3200, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3200, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3200, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3200, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3200, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3200, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3200, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3200, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3200, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3200, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3200, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3200, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3200, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3200, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3200, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3264, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3264, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3264, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3264, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3264, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3264, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3264, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3264, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3264, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3264, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3264, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3264, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3264, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3264, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3264, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3264, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3264, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3264, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3264, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3264, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3264, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3264, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3264, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3264, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3328, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3328, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3328, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3328, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3328, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3328, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3328, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3328, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3328, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3328, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3328, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3328, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3328, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3328, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3328, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3328, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3328, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3328, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3328, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3328, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3328, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3328, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3328, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3328, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3392, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3392, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3392, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3392, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3392, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3392, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3392, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3392, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3392, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3392, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3392, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3392, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3392, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3392, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3392, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3392, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3392, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3392, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3392, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3392, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3392, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3392, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3392, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3392, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3456, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3456, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3456, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3456, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3456, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3456, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3456, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3456, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3456, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3456, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3456, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3456, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3456, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3456, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3456, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3456, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3456, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3456, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3456, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3456, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3456, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3456, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3456, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3456, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3520, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3520, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3520, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3520, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3520, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3520, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3520, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3520, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3520, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3520, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3520, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3520, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3520, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3520, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3520, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3520, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3520, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3520, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3520, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3520, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3520, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3520, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3520, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3520, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3584, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3584, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3584, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3584, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3584, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3584, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3584, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3584, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3584, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3584, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3584, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3584, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3584, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3584, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3584, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3584, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3584, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3584, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3584, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3584, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3584, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3584, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3584, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3584, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3648, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3648, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3648, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3648, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3648, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3648, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3648, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3648, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3648, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3648, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3648, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3648, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3648, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3648, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3648, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3648, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3648, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3648, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3648, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3648, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3648, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3648, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3648, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3648, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3712, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3712, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3712, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3712, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3712, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3712, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3712, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3712, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3712, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3712, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3712, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3712, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3712, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3712, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3712, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3712, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3712, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3712, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3712, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3712, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3712, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3712, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3712, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3712, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3776, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3776, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3776, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3776, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3776, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3776, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3776, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3776, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3776, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3776, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3776, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3776, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3776, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3776, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3776, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3776, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3776, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3776, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3776, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3776, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3776, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3776, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3776, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3776, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3840, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3840, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3840, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3840, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3840, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3840, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3840, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3840, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3840, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3840, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3840, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3840, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3840, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3840, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3840, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3840, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3840, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3840, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3840, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3840, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3840, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3840, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3840, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3840, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3904, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3904, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3904, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3904, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3904, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3904, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3904, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3904, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3904, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3904, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3904, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3904, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3904, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3904, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3904, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3904, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3904, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3904, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3904, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3904, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3904, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3904, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3904, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3904, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3968, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3968, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3968, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3968, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3968, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3968, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3968, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3968, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3968, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3968, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3968, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3968, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3968, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3968, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3968, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3968, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3968, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3968, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3968, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3968, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3968, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 3968, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 3968, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 3968, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4032, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4032, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4032, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4032, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4032, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4032, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4032, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4032, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4032, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4032, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4032, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4032, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4032, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4032, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4032, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4032, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4032, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4032, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4032, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4032, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4032, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4032, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4032, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4032, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4096, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4096, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4096, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4096, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4096, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4096, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4096, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4096, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4096, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4096, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4096, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4096, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4096, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4096, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4096, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4096, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4096, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4096, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4096, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4096, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4096, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4096, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4096, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4096, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4160, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4160, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4160, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4160, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4160, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4160, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4160, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4160, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4160, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4160, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4160, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4160, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4160, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4160, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4160, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4160, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4160, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4160, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4160, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4160, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4160, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4160, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4160, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4160, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4224, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4224, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4224, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4224, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4224, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4224, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4224, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4224, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4224, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4224, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4224, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4224, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4224, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4224, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4224, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4224, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4224, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4224, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4224, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4224, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4224, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4224, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4224, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4224, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4288, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4288, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4288, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4288, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4288, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4288, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4288, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4288, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4288, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4288, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4288, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4288, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4288, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4288, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4288, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4288, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4288, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4288, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4288, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4288, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4288, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4288, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4288, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4288, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4352, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4352, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4352, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4352, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4352, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4352, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4352, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4352, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4352, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4352, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4352, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4352, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4352, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4352, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4352, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4352, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4352, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4352, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4352, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4352, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4352, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4352, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4352, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4352, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4416, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4416, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4416, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4416, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4416, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4416, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4416, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4416, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4416, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4416, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4416, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4416, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4416, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4416, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4416, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4416, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4416, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4416, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4416, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4416, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4416, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4416, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4416, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4416, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4480, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4480, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4480, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4480, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4480, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4480, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4480, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4480, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4480, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4480, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4480, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4480, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4480, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4480, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4480, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4480, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4480, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4480, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4480, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4480, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4480, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4480, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4480, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4480, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4544, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4544, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4544, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4544, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4544, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4544, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4544, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4544, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4544, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4544, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4544, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4544, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4544, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4544, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4544, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4544, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4544, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4544, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4544, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4544, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4544, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4544, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4544, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4544, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4608, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4608, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4608, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4608, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4608, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4608, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4608, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4608, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4608, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4608, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4608, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4608, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4608, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4608, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4608, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4608, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4608, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4608, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4608, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4608, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4608, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4608, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4608, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4608, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4672, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4672, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4672, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4672, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4672, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4672, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4672, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4672, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4672, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4672, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4672, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4672, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4672, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4672, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4672, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4672, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4672, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4672, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4672, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4672, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4672, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4672, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4672, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4672, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4736, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4736, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4736, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4736, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4736, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4736, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4736, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4736, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4736, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4736, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4736, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4736, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4736, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4736, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4736, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4736, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4736, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4736, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4736, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4736, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4736, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4736, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4736, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4736, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4800, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4800, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4800, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4800, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4800, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4800, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4800, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4800, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4800, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4800, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4800, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4800, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4800, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4800, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4800, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4800, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4800, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4800, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4800, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4800, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4800, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4800, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4800, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4800, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4864, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4864, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4864, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4864, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4864, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4864, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4864, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4864, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4864, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4864, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4864, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4864, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4864, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4864, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4864, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4864, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4864, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4864, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4864, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4864, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4864, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4864, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4864, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4864, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4928, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4928, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4928, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4928, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4928, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4928, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4928, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4928, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4928, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4928, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4928, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4928, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4928, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4928, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4928, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4928, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4928, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4928, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4928, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4928, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4928, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4928, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4928, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4928, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4992, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4992, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4992, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4992, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4992, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4992, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4992, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4992, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4992, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4992, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4992, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4992, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4992, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4992, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4992, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4992, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4992, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4992, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4992, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4992, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4992, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 4992, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 4992, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 4992, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5056, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5056, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5056, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5056, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5056, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5056, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5056, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5056, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5056, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5056, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5056, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5056, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5056, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5056, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5056, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5056, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5056, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5056, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5056, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5056, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5056, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5056, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5056, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5056, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5120, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5120, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5120, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5120, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5120, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5120, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5120, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5120, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5120, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5120, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5120, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5120, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5120, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5120, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5120, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5120, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5120, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5120, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5120, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5120, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5120, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5120, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5120, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5120, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5184, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5184, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5184, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5184, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5184, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5184, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5184, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5184, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5184, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5184, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5184, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5184, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5184, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5184, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5184, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5184, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5184, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5184, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5184, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5184, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5184, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5184, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5184, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5184, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5248, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5248, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5248, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5248, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5248, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5248, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5248, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5248, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5248, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5248, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5248, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5248, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5248, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5248, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5248, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5248, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5248, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5248, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5248, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5248, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5248, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5248, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5248, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5248, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5312, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5312, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5312, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5312, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5312, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5312, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5312, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5312, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5312, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5312, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5312, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5312, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5312, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5312, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5312, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5312, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5312, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5312, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5312, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5312, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5312, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5312, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5312, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5312, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5376, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5376, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5376, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5376, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5376, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5376, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5376, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5376, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5376, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5376, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5376, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5376, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5376, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5376, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5376, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5376, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5376, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5376, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5376, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5376, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5376, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5376, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5376, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5376, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5440, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5440, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5440, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5440, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5440, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5440, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5440, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5440, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5440, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5440, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5440, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5440, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5440, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5440, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5440, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5440, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5440, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5440, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5440, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5440, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5440, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5440, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5440, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5440, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5504, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5504, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5504, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5504, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5504, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5504, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5504, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5504, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5504, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5504, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5504, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5504, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5504, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5504, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5504, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5504, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5504, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5504, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5504, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5504, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5504, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5504, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5504, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5504, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5568, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5568, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5568, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5568, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5568, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5568, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5568, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5568, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5568, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5568, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5568, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5568, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5568, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5568, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5568, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5568, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5568, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5568, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5568, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5568, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5568, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5568, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5568, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5568, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5632, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5632, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5632, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5632, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5632, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5632, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5632, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5632, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5632, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5632, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5632, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5632, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5632, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5632, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5632, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5632, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5632, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5632, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5632, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5632, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5632, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5632, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5632, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5632, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5696, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5696, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5696, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5696, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5696, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5696, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5696, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5696, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5696, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5696, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5696, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5696, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5696, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5696, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5696, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5696, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5696, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5696, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5696, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5696, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5696, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5696, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5696, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5696, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5760, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5760, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5760, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5760, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5760, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5760, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5760, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5760, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5760, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5760, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5760, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5760, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5760, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5760, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5760, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5760, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5760, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5760, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5760, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5760, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5760, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5760, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5760, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5760, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5824, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5824, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5824, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5824, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5824, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5824, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5824, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5824, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5824, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5824, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5824, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5824, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5824, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5824, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5824, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5824, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5824, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5824, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5824, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5824, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5824, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5824, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5824, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5824, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5888, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5888, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5888, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5888, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5888, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5888, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5888, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5888, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5888, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5888, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5888, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5888, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5888, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5888, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5888, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5888, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5888, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5888, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5888, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5888, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5888, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5888, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5888, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5888, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5952, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5952, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5952, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5952, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5952, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5952, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5952, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5952, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5952, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5952, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5952, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5952, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5952, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5952, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5952, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5952, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5952, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5952, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5952, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5952, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5952, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 5952, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 5952, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 5952, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6016, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6016, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6016, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6016, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6016, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6016, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6016, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6016, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6016, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6016, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6016, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6016, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6016, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6016, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6016, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6016, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6016, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6016, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6016, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6016, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6016, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6016, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6016, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6016, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6080, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6080, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6080, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6080, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6080, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6080, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6080, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6080, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6080, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6080, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6080, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6080, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6080, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6080, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6080, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6080, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6080, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6080, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6080, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6080, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6080, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6080, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6080, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6080, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6144, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6144, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6144, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6144, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6144, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6144, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6144, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6144, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6144, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6144, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6144, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6144, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6144, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6144, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6144, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6144, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6144, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6144, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6144, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6144, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6144, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6144, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6144, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6144, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6208, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6208, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6208, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6208, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6208, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6208, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6208, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6208, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6208, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6208, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6208, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6208, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6208, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6208, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6208, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6208, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6208, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6208, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6208, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6208, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6208, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6208, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6208, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6208, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6272, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6272, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6272, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6272, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6272, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6272, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6272, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6272, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6272, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6272, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6272, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6272, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6272, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6272, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6272, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6272, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6272, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6272, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6272, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6272, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6272, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6272, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6272, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6272, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6336, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6336, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6336, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6336, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6336, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6336, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6336, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6336, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6336, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6336, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6336, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6336, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6336, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6336, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6336, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6336, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6336, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6336, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6336, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6336, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6336, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6336, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6336, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6336, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6400, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6400, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6400, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6400, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6400, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6400, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6400, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6400, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6400, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6400, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6400, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6400, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6400, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6400, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6400, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6400, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6400, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6400, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6400, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6400, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6400, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6400, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6400, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6400, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6464, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6464, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6464, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6464, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6464, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6464, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6464, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6464, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6464, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6464, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6464, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6464, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6464, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6464, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6464, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6464, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6464, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6464, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6464, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6464, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6464, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6464, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6464, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6464, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6528, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6528, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6528, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6528, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6528, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6528, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6528, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6528, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6528, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6528, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6528, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6528, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6528, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6528, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6528, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6528, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6528, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6528, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6528, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6528, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6528, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6528, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6528, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6528, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6592, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6592, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6592, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6592, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6592, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6592, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6592, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6592, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6592, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6592, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6592, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6592, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6592, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6592, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6592, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6592, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6592, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6592, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6592, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6592, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6592, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6592, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6592, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6592, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6656, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6656, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6656, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6656, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6656, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6656, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6656, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6656, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6656, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6656, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6656, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6656, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6656, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6656, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6656, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6656, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6656, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6656, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6656, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6656, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6656, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6656, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6656, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6656, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6720, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6720, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6720, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6720, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6720, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6720, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6720, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6720, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6720, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6720, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6720, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6720, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6720, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6720, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6720, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6720, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6720, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6720, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6720, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6720, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6720, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6720, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6720, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6720, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6784, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6784, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6784, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6784, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6784, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6784, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6784, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6784, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6784, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6784, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6784, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6784, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6784, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6784, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6784, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6784, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6784, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6784, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6784, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6784, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6784, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6784, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6784, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6784, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6848, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6848, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6848, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6848, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6848, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6848, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6848, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6848, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6848, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6848, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6848, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6848, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6848, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6848, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6848, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6848, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6848, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6848, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6848, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6848, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6848, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6848, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6848, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6848, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6912, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6912, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6912, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6912, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6912, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6912, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6912, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6912, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6912, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6912, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6912, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6912, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6912, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6912, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6912, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6912, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6912, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6912, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6912, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6912, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6912, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6912, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6912, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6912, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6976, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6976, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6976, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6976, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6976, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6976, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6976, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6976, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6976, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6976, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6976, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6976, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6976, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6976, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6976, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6976, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6976, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6976, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6976, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6976, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6976, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 6976, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 6976, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 6976, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7040, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7040, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7040, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7040, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7040, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7040, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7040, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7040, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7040, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7040, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7040, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7040, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7040, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7040, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7040, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7040, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7040, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7040, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7040, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7040, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7040, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7040, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7040, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7040, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7104, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7104, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7104, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7104, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7104, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7104, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7104, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7104, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7104, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7104, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7104, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7104, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7104, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7104, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7104, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7104, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7104, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7104, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7104, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7104, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7104, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7104, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7104, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7104, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7168, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7168, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7168, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7168, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7168, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7168, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7168, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7168, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7168, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7168, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7168, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7168, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7168, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7168, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7168, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7168, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7168, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7168, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7168, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7168, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7168, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7168, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7168, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7168, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7232, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7232, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7232, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7232, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7232, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7232, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7232, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7232, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7232, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7232, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7232, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7232, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7232, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7232, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7232, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7232, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7232, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7232, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7232, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7232, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7232, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7232, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7232, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7232, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7296, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7296, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7296, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7296, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7296, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7296, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7296, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7296, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7296, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7296, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7296, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7296, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7296, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7296, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7296, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7296, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7296, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7296, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7296, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7296, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7296, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7296, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7296, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7296, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7360, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7360, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7360, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7360, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7360, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7360, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7360, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7360, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7360, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7360, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7360, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7360, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7360, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7360, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7360, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7360, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7360, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7360, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7360, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7360, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7360, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7360, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7360, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7360, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7424, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7424, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7424, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7424, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7424, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7424, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7424, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7424, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7424, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7424, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7424, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7424, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7424, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7424, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7424, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7424, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7424, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7424, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7424, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7424, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7424, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7424, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7424, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7424, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7488, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7488, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7488, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7488, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7488, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7488, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7488, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7488, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7488, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7488, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7488, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7488, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7488, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7488, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7488, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7488, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7488, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7488, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7488, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7488, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7488, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7488, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7488, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7488, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7552, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7552, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7552, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7552, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7552, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7552, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7552, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7552, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7552, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7552, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7552, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7552, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7552, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7552, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7552, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7552, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7552, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7552, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7552, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7552, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7552, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7552, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7552, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7552, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7616, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7616, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7616, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7616, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7616, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7616, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7616, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7616, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7616, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7616, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7616, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7616, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7616, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7616, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7616, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7616, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7616, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7616, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7616, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7616, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7616, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7616, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7616, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7616, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7680, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7680, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7680, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7680, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7680, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7680, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7680, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7680, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7680, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7680, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7680, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7680, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7680, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7680, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7680, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7680, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7680, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7680, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7680, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7680, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7680, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7680, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7680, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7680, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7744, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7744, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7744, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7744, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7744, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7744, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7744, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7744, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7744, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7744, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7744, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7744, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7744, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7744, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7744, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7744, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7744, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7744, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7744, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7744, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7744, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7744, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7744, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7744, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7808, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7808, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7808, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7808, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7808, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7808, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7808, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7808, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7808, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7808, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7808, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7808, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7808, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7808, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7808, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7808, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7808, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7808, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7808, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7808, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7808, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7808, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7808, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7808, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7872, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7872, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7872, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7872, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7872, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7872, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7872, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7872, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7872, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7872, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7872, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7872, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7872, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7872, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7872, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7872, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7872, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7872, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7872, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7872, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7872, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7872, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7872, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7872, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7936, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7936, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7936, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7936, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7936, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7936, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7936, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7936, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7936, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7936, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7936, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7936, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7936, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7936, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7936, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7936, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7936, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7936, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7936, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7936, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7936, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 7936, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 7936, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 7936, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 8000, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 8000, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 8000, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 8000, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 8000, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 8000, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 8000, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 8000, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 8000, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 8000, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 8000, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 8000, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 8000, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 8000, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 8000, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 8000, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 8000, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 8000, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 8000, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 8000, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 8000, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 8000, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 8000, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 8000, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 8064, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 8064, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 8064, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 8064, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 8064, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 8064, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 8064, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 8064, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 8064, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 8064, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 8064, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 8064, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 8064, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 8064, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 8064, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 8064, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 8064, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 8064, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 8064, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 8064, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 8064, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 8064, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 8064, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 8064, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 8128, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 8128, %arg6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 8128, %arg6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 8128, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 8128, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 8128, %arg6 + 1] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 8128, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 8128, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 8128, %arg6 + 2] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 8128, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 8128, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 8128, %arg6 + 3] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 8128, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 8128, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 8128, %arg6 + 4] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 8128, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 8128, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 8128, %arg6 + 5] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 8128, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 8128, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 8128, %arg6 + 6] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
        affine.for %arg7 = 0 to 8 {
          %0 = affine.load %arg2[%arg7 + 8128, %arg5] {partition_indices = [0, 0], timing = #hls.t<0 -> 2, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %1 = arith.mulf %arg0, %0 {timing = #hls.t<2 -> 6, 4, 1>} : f32
          %2 = affine.load %arg3[%arg5, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<4 -> 6, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %3 = arith.mulf %2, %1 {timing = #hls.t<6 -> 10, 4, 1>} : f32
          %4 = affine.load %arg4[%arg7 + 8128, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<8 -> 10, 2, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
          %5 = arith.addf %3, %4 {timing = #hls.t<10 -> 15, 5, 1>} : f32
          affine.store %5, %arg4[%arg7 + 8128, %arg6 + 7] {partition_indices = [0, 0], timing = #hls.t<15 -> 16, 1, 1>} : memref<1024x1024xf32, affine_map<(d0, d1) -> (0, 0, d0, d1)>>
        } {loop_info = #hls.l<flattenTripCount=8, iterLatency=16, minII=16>, timing = #hls.t<0 -> 130, 130, 130>}
      } {loop_directive = #hls.ld<pipeline=false, targetII=1, dataflow=false, flatten=true>, loop_info = #hls.l<flattenTripCount=1024, iterLatency=16, minII=16>, timing = #hls.t<0 -> 16386, 16386, 16386>}
    } {loop_directive = #hls.ld<pipeline=false, targetII=1, dataflow=false, flatten=true>, loop_info = #hls.l<flattenTripCount=1048576, iterLatency=16, minII=16>, timing = #hls.t<7342082 -> 24119300, 16777218, 16777218>}
    return {timing = #hls.t<24119300 -> 24119300, 0, 0>}
  }
}